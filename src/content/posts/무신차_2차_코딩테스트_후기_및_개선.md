---
title: "무신사 2차 코딩테스트 후기 및 개선"
description: "무신사 2차 코딩테스트를 참가한 후기와 추가 개선사항"
date: 2026-02-22
category: backend
tags:
  - ai native
  - redis
  - sse
  - spring boot
draft: false
featured: true
author: 박용준
---

2월 8일, 무신사 ROOKIE AI NATIVE ENGINEER 2차 코딩테스트를 치르고 왔습니다...!

![2차 코딩테스트 메일](/images/2026-02-22/musinsa-ai-rookie-mail.png)

사실 1차 코딩테스트를 생각보다 잘 본 듯한 느낌이 들어서 (지극히 개인적으로...)

2차 코테는 어떨까..? 하는 마음이 있었는데 메일을 받아보니, 그리고 실제로 겪어보니 정말 처음 경험해보는 코테였습니다.

크게 2가지 특징이 있었습니다.

- AI Agent를 자유롭게 사용 가능
- 웹 서버 구축

확실히 AI Native Engineer 를 뽑는 채용 공고이다 보니, AI Agent 활용 능력도 큰 평가 대상이었습니다.

또한 과제 내용은 생각보다 익숙한 서버 어플리케이션 개발이었습니다.

뭔가 예상으로는 AI Agent를 활용해서 실제 다른 Agent를 만드는 과제가 나올까? 하는 생각을 했지만,

과제 주제 자체는 무난하게 출제가 되었습니다.

---

# 시험 회고

미리 뭔가를 더 준비해놓고 시험을 시작했어야 하는 생각이 가장 먼저 들었습니다....

저는 AI 활용 능력이 중점이기 때문에 미리 템플릿을 만들거나, skill을 작성해두지 않았습니다.

이런 툴 사용 능력도 평가 대상에 포함될 거 같았거든요...(저만의 착각일 수도 있겠습니다 ㅠㅠ)

결과부터 말하자면, 생각보다 굉장히 결과물이 마음에 들지 않았습니다.

평소에 AI를 자주 사용하기 때문에 큰 걱정을 하지 않고 시험에 임했는데, 저는 개인적으로 시간이 부족했습니다.

가장 부족했던 능력은 다음과 같았습니다.

- AI를 사용한 요구 사항 분석
- 적합한 단위로 태스크를 분할하여 AI에 구현 요구
- 체계화된 문서 작성

시험을 치르고 나서 꽤나 많은 것을 배우고 스스로 복기를 많이 했습니다.

---

# 시험 결과

![2차 코딩테스트 합격 메일](/images/2026-02-22/musinsa-ai-rookie-mail-2.png)

뭐지...? 하는 생각이 제일 처음 들었습니다.

그렇게 큰 기대를 하지 않았는데, 합격이라니.... 감사합니다...!

기회가 왔으니, 노를 저어보겠습니다.

면접까지 열심히 준비해서 보고 오도록 하겠습니다...!

---

# 추가 개선

시험 결과와는 별개로 이번 과제를 진행하면서, 개인적으로 아쉬웠던 부분과 더 추가하고 싶었던 기능이 있었습니다.

그래서, 프로젝트의 수정과 보완을 진행하려고 합니다.

## 1차 개선

처음으로 개선할 수 있는 포인트는 락이 걸리는 위치입니다.

![기존 다이어그램](/images/2026-02-22/as-is-diagram.png)

기존에는 DB Lock을 획득한 이후

- validation 수행
  - 학생 존재 유무 확인
  - 강의 존재 유무 확인
  - 학년 제한
  - 재수강 제한
  - 시간표 중복
  - 중복 수강
  - 학점 초과
  - 정원 초과

로직을 모두 수행한 이후 수강 신청에 성공하게 됩니다.

위 처럼 구현을 했을 때 발생하는 문제는 다음과 같습니다.

> **가정**
>
> 수강신청 트랜잭션 시간 = ~100ms (검증 + DB 락)
>
> **처리량 계산**
>
> 초당 처리량 = 1000ms / 100ms = 10 requests/sec
>
> 100명 동시 신청 = **10초 소요**

정직하게 직렬화된 처리 방식이기 때문에, 수강신청에 많은 사람이 몰릴 수록 사용자 경험은 극도로 제한될 수 밖에 없습니다.

![1차 개선 다이어그램](/images/2026-02-22/first-refactoring.png)

따라서 Lock이 적용되는 범위를 줄여서 최대한 병렬 처리가 가능하도록 개선이 필요합니다.

### Student Lock

학생에 대해선 DB 락을 걸 필요가 없습니다.

DB 락을 걸어야 하는 상황은 **데이터 정합성**이 중요한 경우인데, 학생의 경우 **중복 실행**만 방지하여도 충분하기 때문입니다.

따라서 Redisson의 RLock을 적용해서 중복 실행을 방지 했습니다.

이렇게 학생에 대해 Lock을 걸게되면 많은 validation을 DB 락 범위 밖에서 수행할 수 있습니다.

- 학생 존재 유무 확인
- 강의 존재 유무 확인
- 학년 제한
- 재수강 제한

위 4가지 제약 조건은 과거의 데이터를 사용하거나, 존재의 유무를 확인하는 로직을 수행하기에 Lock의 위치가 중요하지 않습니다.

따라서 쉽게 Lock 범위 밖으로 위치시킬 수 있습니다.

- 시간표 중복
- 중복 수강
- 학점 초과

하지만, 위 3가지 조건은 함부로 Lock 범위 밖으로 위치시킬 수 없습니다.

수강신청을 시도하는 순간 Race Condition이 발생해 Write Skew 현상이 발생할 수 있기 때문입니다.

그래도 저는 Lock 범위 밖으로 위치시켰습니다.

그 이유는 처음에 student id를 대상으로 Redisson Lock을 걸었기 때문입니다.

단일 학생에 대해서 중복 실행이 불가능하고, 3가지 조건은 한 명의 학생에 한하여 Race Condition이 발생하기 때문입니다.

이처럼 Lock 범위만 다르게 설정하여도, 기존에 비해 성능 개선을 이룰 수 있습니다.

> **기존**
>
> Lock 보유 시간: 100ms (가정)
>
> 처리량 : 1000ms / 100ms = 10 req/sec
>
> **개선 이후**
>
> Lock 보유 시간 : 30ms (가정)
>
> (검증 로직은 Lock 범위 밖에서 병렬 실행)
>
> 처리량 : 1000ms / 30ms = 33 req/sec

## 최종 개선

과제의 요구사항대로 구현한다면 1차 개선으로 충분하긴 합니다.

사실, Redisson Lock도 사용하지 않아도 됩니다. 요구사항의 트래픽이라면 단일 인스턴스로도 충분히 대응이 가능하니까요.

저희는 항상 기술을 도입할 때의 Trade-Off에 대해 고민을 해야 합니다.

Redisson Lock을 사용한다면, 분산 환경에서의 동시성 제어가 가능하지만

대신 ReentrantLock을 사용한다면, Redis 인프라 구축 및 관리 비용 + 모니터링 비용을 아낄 수 있습니다.

하지만, 개인적으로 추가로 구현해보고 싶은 기능이 있어 Redis를 사용했습니다.

최종적으로 개선할 부분은 다음과 같습니다.

- 대기열 구현
- 병렬 처리

![대기열](/images/2026-02-22/대기열.png)

저는 대학생 때 수강신청을 할 때마다, 너무 오래 걸리는 걸리는 것을 떠나서 제가 몇 번째 순서로 수강신청을 했는지 알고 싶었습니다.

따라서 이번 프로젝트에서 해당 기능을 한 번 구현해보고자 했습니다.

대기열을 사용하려면, 우선 대기열에 등록하는 과정이 필요하겠죠?

대기열을 구현하기 위해선 2가지 방법을 사용 가능합니다.

- Redis Sorted Set
- Message Queue (MQ)

결론적으로 저는 **Redis Sorted Set**을 사용했습니다.

그 이유가 무엇일까요?

정답은 제가 첨부한 사진에 있습니다.

두 가지 방법 모두 대기열로서의 기능을 제공하지만, **순번**을 조회하기 위해선 Redis Sorted Set을 사용해야 합니다.

Message Queue의 경우 기본적으로 Consume 시 메세지를 소비하기 때문에, 조회 접근이 어려운 특징을 가지고 있습니다.

메세지를 Offset 기반으로 소비할 메시지를 확인할 뿐, 특정 클라이언트가 어떤 순번에 있는지 확인하기 어렵습니다.

하지만, Redis의 Sorted Set은 대기열 자체를 데이터로 관리하기 때문에, ZRANK 등의 명령어로 순번을 확인할 수가 있습니다.

---

![최종 다이어그램](/images/2026-02-22/last-refactoring.png)

1차 개선에 비해서 꽤나 복잡해진 다이어그램입니다.

### 큐 등록 및 SSE 스트림 연결

Phase 1에서는 요청을 대기열에 등록합니다.

이때 중요한 점은 대기열 등록 시 course_id를 사용한다는 점입니다.

student_id와 course_id를 동시에 사용함에도 불구하고 course_id를 등록하는 이유는 수강신청 경험을 위해서 입니다.

수강신청을 하는 사용자 입장에서는 **전체 대기자 수** 보다는 **수강신청할 강의의 대기자 수**를 확인하고 싶으니까요.

이후 course_id와 student_id를 기반으로 ticket을 발행합니다.

해당 ticket은 클라이언트에서 SSE 스트림을 연결할 때에도 사용하고, 대기열에서 순서대로 요청을 처리할 때에도 사용할 수 있습니다.

그 다음 클라이언트는 SSE 스트림을 연결하게 됩니다.

여기서도 한 가지 의문점이 생길 수 있습니다. 왜 SSE 스트림을 사용했을까요?

대기열 순번을 확인을 할 수 있는 방법은 크게 2가지가 있습니다.

- Polling
- Server-Sent Event (SSE)

Polling 방식은 클라이언트가 주기적으로 서버에 요청을 보내서 데이터를 확인하는 방법이고,

SSE는 서버가 일방적으로 클라이언트에게 데이터를 푸시하는 방법입니다.

제가 SSE를 선택한 이유는 순번이 변할 때 즉각적으로 클라이언트에게 정보를 전달하는 실시간성을 보장하기 위해서 입니다. (사실 제가 한번 시도해보고 싶은 방법이기도 했습니다...ㅎㅎ)

수강신청의 경우 한번의 성공으로 라이프사이클이 끝나지 않습니다. 학생은 바로 다음 강의 수강 신청을 진행해야 하죠.

일종의 선착순 게임이 계속 진행되는데, Polling 방식을 사용하게 되면 수강신청이 성공한 시점을 정확히 알 수가 없습니다.

다만, 접속자가 많아지게 된다면 SSE 방식이 아닌 Polling 방식을 사용해야 합니다.

SSE를 사용하게 되면 클라이언트와 서버가 계속 연결을 유지하기 때문에, 대규모 트래픽에서는 리소스가 굉장히 낭비될 뿐만 아니라 추후 모종의 이유로 연결이 끊기고 난 뒤에 일괄 재접속을 할 경우 DDoS 공격과 비슷한 효과로 서버가 다운될 수 있습니다.

### 워커 비동기 처리 및 결과 전달

대기열 등록을 하고, SSE 스트림이 연결될 동안 서버가 계속 기다릴 필요는 없습니다.

바로 처리가 가능하도록 비동기 작업을 진행합니다.

`ZPOPMIN`을 사용해서 가장 오래된 요청을 들고와서 작업을 시작합니다.

작업 수행 방식은 1차 개선 때와 동일합니다. (1) student_id에 대해서 RLock을 획득하고, (2) DB Lock 범위 밖에서 제약 조건을 체크한 뒤, (3) DB Lock 내에서 정원 체크 후 수강신청을 마무리 합니다.

위 과정을 수행하고 난 뒤,

- 성공한 ticket에 대한 성공 결과
- 해당 강좌의 순번
  정보를 publish 합니다.

클라이언트는 SSE 스트림을 연결해둔 상태이기 때문에 본인의 수강신청이 성공 여부와 대기 순번을 이때 확인할 수 있습니다.

### 결과 (1000VU)

![결과](/images/2026-02-22/result.png)

| 구분     | Sync p50 (ms) | Queue p50 (ms) | Sync p95 (ms) | Queue p95 (ms) |
| -------- | ------------- | -------------- | ------------- | -------------- |
| 평균     | 232.39        | 71.06          | 375.71        | 572.43         |
| 중앙값   | 208           | 32.7           | 343           | 532            |
| 최소값   | 20            | 6.53           | 27.5          | 31.6           |
| 최대값   | 981           | 905            | 1424          | 2169           |
| 표준편차 | 140.3         | 98.3           | 217.5         | 343.7          |

결과를 보면, 동기적 (1차 개선) 방식이 응답 속도는 더 빠른 것을 확인할 수 있습니다. 왜 그럴까요?

1차 개선안과 최종 개선안의 차이는 **병렬 처리 가능 구간** 입니다.

1차 개선안은 **학생별**로 **course_id별** 로 Lock을 걸고 있습니다.

그리고 학생별 Lock과 course_id Lock 사이는 다른 학생이라면 병렬 처리가 가능합니다.

하지만 최종 개선안은 course_id 순서대로 요청을 Queue로 처리하고 있습니다. 또한 SSE 스트림 연결로 인한 트래픽도 무시할 수 없습니다.

따라서 제약 조건을 체크하는 과정에서 직렬화된 요청을 처리하기 때문에 병목이 일부 발생한거죠.

대기열을 사용하는 것은 기본적으로 **성능을 개선하기 위한 방법**은 아닙니다. 요청을 분산하고, 처리 순서를 지정함으로서 안정성을 확보하는 작업입니다.

물론 대기열에서 course id를 제거하는 순서를 제어하고, Queue에서 처리할 배치를 컨트롤하거나 병렬 처리 및 Polling 방식으로 변경함으로서 성능 개선도 가능합니다.

이렇듯 기술을 선택할 때에는 Trade-Off를 고려하여 선택해야 합니다.

저는 대기열을 구현하기 위해서 Redis의 Sorted Set + SSE를 사용했지만, 만약 과제의 요구사항과 같은 상황이었다면 오히려 1차 개선안으로 적용하는 편이 좋을 수 있습니다.

P95의 최대값이 1.4초 정도이고, 이 정도 시간 안에 대기 순번을 확인하는 것이 큰 의미를 가지지 않을 수도 있기 때문입니다.

---

여기까지 무신사 2차 코테에 대한 회고와 개선 과정을 적어보았습니다.

색다른 방식으로 코테를 진행하기도 했고, 개선하는 과정도 굉장히 즐거웠습니다.

물론 코테를 진행할 때의 제가 가진 지식과 경험이 부족해서, 좀 더 좋은 퀄리티의 결과물을 제출하지 못한 후회는 남아있습니다.

하지만, 그 경험을 기반으로 더 많은 공부를 할 수 있었고 그 결과 지금 AI 활용 능력을 더 키울 수 있던 것 같습니다.

앞으로도 계속 도전과 레슨런을 기반으로 성장해보겠습니다...!
